在我之前的影片中，我向您展示瞭如何使用「sqlx」和「pq」連接到 Go 中的 Postgres 資料庫。
我們還創建了一個資料庫表來儲存用戶資料。
今天，我想在此基礎上使用 Argon2 實現密碼身份驗證。
如果您看過我之前的視頻，您可以從我們上次停下的地方繼續，但如果您沒有看過，也沒關係。
下面的描述中有 Github 儲存庫，您可以使用它作為起點。
首先，我們需要了解密碼雜湊演算法的工作原理。
這是鮑伯。鮑伯想在我們關於程式設計影片的網站上建立一個帳戶。他輸入他的電子郵件地址和密碼。
我們需要對他的密碼進行轉換，以便我們可以隨時檢查密碼是否正確。
但是，我們還需要確保壞人無法僅通過查看加密形式輕鬆猜出他的密碼是什麼。
這就是發明密碼雜湊演算法的原因。
我們取得鮑伯的密碼，將其與稱為「鹽」的隨機值混合在一起，並應用某種複雜而緩慢的計算，最終得到一個如下所示的字串。
該字串包含雜湊演算法的標識符、其參數、加鹽值以及上述計算的結果。
每當鮑伯想要登入時，我們都會取得他的密碼，添加鹽並應用相同的計算。
如果我們最終得到相同的值，則表示密碼是正確的，我們可以讓 Bob 進入系統。
在本影片中，我們將使用名為「argon2id」的密碼雜湊庫。
讓我們從安裝這個庫開始。如果您找不到它，可以在下面的描述中找到一個連結。打開終端機並 cd 進入我們在上一個影片中啟動的「goma」專案的目錄。在軟體包的網站上，按一下剪貼簿圖示將匯入路徑複製到系統剪貼簿。
然後，在終端機中輸入 go get，然後貼上導入路徑並按 Enter。
使用「mkdir -p」在「exp/argon」處建立一個目錄，然後在該目錄中建立一個名為「main.go」的檔案並在程式碼編輯器中開啟它。
「exp」代表「實驗性」，因為我們將在將密碼雜湊演算法整合到更大的系統之前編寫一個較小的程式。
在此檔案中，定義「package main」和「func main()」。
在「main」內部，我們定義一個「password」變量，然後根據純文字密碼和預設雜湊參數建立一個新的密碼雜湊。
如果在雜湊過程中發生任何錯誤，我們會記錄錯誤並退出，否則我們會列印雜湊密碼。
接下來，我們嘗試幾個密碼，看看它們是否匹配。
對於每個密碼，我們都會執行檢查，如果出現任何錯誤，我們會將錯誤記錄到標準輸出並退出。
否則，我們列印測試過的密碼和檢查結果。
當我們運行這個程式時，我們應該看到一個密碼雜湊字串列印到終端。
下面，我們可以看到我們測試過的所有密碼。 可以看到，只有原始密碼與測試相符。
如果多次執行該程序，您可能會注意到每次的密碼摘要都不同。
這是因為鹽漬值是隨機的。
該演算法就是以這種方式設計的，以便在資料庫洩漏的情況下，破壞一個密碼雜湊不會危及其他帳戶。
首先，讓我快速解釋一下我們要實施的專案結構。
如果您曾經使用過 Web 框架，您可能會熟悉 MVC 設計模式。
MVC 代表「模型-視圖-控制器」，這意味著應用程式工作流程大致分為三個部分。
控制器負責處理傳入的 HTTP 請求並將回應傳回給客戶端。
模型通常與資料庫互動並驗證資料。
視圖層負責將資料呈現為 HTML 或 JSON。
但實際上，在許多情況下，您需要實作似乎不適合模型或控制器的複雜邏輯。
因此，一些框架提出了位於控制器和模型之間的另一層。
在 Elixir 的 Web 框架 Phoenix 中，這些被稱為「上下文」。
在 Rails 中，您可以使用稱為「服務」的模式。
在本影片中，我們沒有使用框架，因此沒有真正的專案結構。 我們將編寫一個「儲存」，其中包含負責簡單資料庫互動的邏輯。 在商店之上，我們將實現一個「服務」，它將處理更複雜的邏輯，例如我們今天要實現的密碼身份驗證工作流程。
控制器和視圖超出了該視訊的範圍。
讓我們從定義使用者類型開始。
回到專案的根目錄，建立一個名為「types」的目錄。
在這個目錄裡面，建立一個名為 user.go 的檔案並在程式碼編輯器中開啟它。
先定義包名稱，然後定義一個「User」結構。
我們需要將資料庫表中的每一列對應到結構上的欄位。
對於「id」列，我們定義一個名為「ID」的結構體字段，有兩個大寫字母。
結構中的每一列都必須以大寫字母開頭，否則「sqlx」將無法將列對應到各自的結構欄位。
由於結構體欄位名稱與資料庫中的列名稱不同，因此我們需要在欄位類型後面新增註釋，告訴 sqlx 將此欄位與 id 欄位相符。
然後我們對「電子郵件」做類似的事情。
對於「password_hash」列，我們需要將結構體欄位定義為字串指標。
這是因為對應的資料庫列沒有「not null」約束。
使用指標類型，「sqlx」可以將空值對應到空指標。
如果我們使用常規值類型，嘗試掃描空值將導致執行時間錯誤。
對於其餘兩列，我們使用「time.Time」。 這是 Go 標準庫中日期和時間的預設資料類型。
現在我們已經定義了「User」結構，讓我們建立一個「store」。
在此設定中，「儲存」模組應定義直接與持久層互動的操作，例如插入、讀取或刪除資料。
對於更高級的用例，例如資料驗證或密碼雜湊，我們稍後將定義另一個稱為「服務」的模組。
在專案的根目錄中，建立一個名為「store」的目錄。
在此目錄中，建立一個名為「user_store.go」的檔案並在程式碼編輯器中開啟它。
首先定義包名稱，然後定義一個名為「UserStore」的結構。
該結構只有一個名為 DB 的字段，我們可以在其中儲存指向「sqlx」資料庫連接的指標。
透過在儲存結構中保留我們自己的資料庫連接，我們可以編寫連接到專用測試資料庫的單元測試。
定義一個名為「NewUserStore」的函數，它接受資料庫連接並傳回一個「UserStore」結構。
在函數體內，傳回具有相同資料庫連接的「UserStore」結構。
由於結構體上的 db 字段是私有的，因此只有同一包中的函數才能設定該字段，這就是我們需要定義建構函數的原因。
在「UserStore」類型上定義一個名為「InsertUser」的方法。
此方法接受指向 User 結構的指標並傳回指向 User 結構的指標和錯誤。
在此方法中，首先定義一個變數來儲存 SQL 查詢的結果。
然後，在資料庫連接上使用「Get」方法，執行此插入查詢並將傳回的資料掃描到「result」變數中。
對於「users」表，我們只需提供「email」和「password_hash」兩列，對於其他所有內容，我們可以依賴資料庫產生的值。
因此，我們在 SQL 語法中定義了兩個佔位符，並將電子郵件和密碼雜湊值作為參數傳遞。
由於我們在查詢中新增了「returning *」子句，因此資料庫將傳回新插入記錄的所有欄位。
如果發生任何錯誤，我們將傳回「nil」和一條包裝的錯誤訊息。 否則，我們傳回一個指向「result」變數的指標和一個「nil」錯誤。
此時，我們有一個看起來應該可以正常工作的函數，但是我們沒有使用者介面來檢查它是否工作。
讓我們來寫一些單元測試。
有些人可能會認為單元測試永遠不應該接觸真正的資料庫，並且與資料庫對話的測試實際上是整合測試，但老實說，我不在乎。
首先，我們需要一個資料庫，並且必須在該資料庫上執行遷移。
由於這是我們將來必須多次執行的任務，因此將其編寫為「make」目標是有意義的，這樣我們就可以將其自動化。
由於我使用的是 Debian，因此我係統上的「make」將是 GNU make。
如果您使用的是 macOS 或 BSD 系統，則系統上的預設 make 可能是 BSD make，在這種情況下，您可能必須單獨安裝 GNU make 並將所有 `make` 命令作為 `gmake` 運行。
在專案的根目錄中，建立一個名為「Makefile」的文件，首字母大寫，並在文字編輯器中開啟它。
現在，我們將定義一個名為「db.test.prepare」的「目標」。
首先，鍵入目標的名稱，後面跟著冒號。
以下行將包含說明，並且必須縮排一個製表符。
建立測試資料庫，並忽略任何錯誤。
這是僅在資料庫不存在時建立資料庫的最簡潔方法。
然後，使用「goose up」運行遷移，將「TEST_DATABASE_URL」變數傳遞給「goose」作為連接字串。
行開頭的 at 符號 (@) 指示 make 在執行指令之前不要列印該指令。
現在，在此目標中，我們引用兩個環境變量，一個用於數據基本名稱和連接字串的另一個名稱。
在執行任何操作之前，我們需要確保這兩個變數都已設定。
為此，我們可以實現一個守衛。
新增一個名為「guard-%」的目標，並在其中加入這個看起來可怕的指令。 現在，「test -n」所做的只是檢查其參數是否為非空字串，如果該命令失敗，我們會使用「echo」列印一條不錯的錯誤訊息，並以非零退出程式碼退出。
現在，將這兩個防護加入為「db.test.prepare」目標的依賴項。
如果您現在嘗試執行「make db.test.prepare」，您將收到錯誤訊息，因為這些環境變數都沒有定義。
讓我們將這兩個環境變數加入到我們的「.envrc」檔案中。
將「TEST_DATABASE_NAME」設為「goma_test」，然後將「TEST_DATABASE_URL」設定為該資料庫的連接字串。
請注意，螢幕上的表達式使用變數插值而不是硬編碼名稱。
如果您已正確配置 `direnv`，當您儲存此檔案並開啟新 shell 時，您應該會看到一條錯誤訊息，要求您執行 `direnvallow`。
如果您不使用「direnv」，則可以透過取得此檔案來設定正確的環境變數。
當您現在執行「make db.test.prepare」時，它應該正確建立資料庫並執行遷移。
您可以透過連接到資料庫並查看其架構來驗證這一點。
現在，在此目標中，我們引用兩個環境變量，一個用於資料庫名稱，另一個用於連接字串。
在執行任何操作之前，我們需要確保這兩個變數都已設定。
為此，我們可以實現一個守衛。
新增一個名為「guard-%」的目標，並在其中加入這個看起來可怕的指令。 現在，「test -n」所做的只是檢查其參數是否為非空字串，如果該命令失敗，我們會使用「echo」列印一條不錯的錯誤訊息，並以非零退出程式碼退出。
現在，將這兩個防護加入為「db.test.prepare」目標的依賴項。
如果您現在嘗試執行「make db.test.prepare」，您將收到錯誤訊息，因為這些環境變數都沒有定義。
讓我們將這兩個環境變數加入到我們的「.envrc」檔案中。
將「TEST_DATABASE_NAME」設為「goma_test」，然後將「TEST_DATABASE_URL」設定為該資料庫的連接字串。
請注意，螢幕上的表達式使用變數插值而不是硬編碼名稱。
如果您已正確配置 `direnv`，當您儲存此檔案並開啟新 shell 時，您應該會看到一條錯誤訊息，要求您執行 `direnvallow`。
如果您不使用「direnv」，則可以透過取得此檔案來設定正確的環境變數。
當您現在執行「make db.test.prepare」時，它應該正確建立資料庫並執行遷移。
您可以透過連接到資料庫並查看其架構來驗證這一點。
在測試中，我們將使用一個名為「testify」的函式庫來改善我們的測試體驗。
在Go套件註冊表中的testify套件網站上，將testify的匯入路徑複製到系統剪貼簿中。
在專案的根目錄中，使用「go get」安裝包，貼上導入路徑。
現在，在「store」目錄中，建立一個名為「store_test.go」的文件，然後在文字編輯器中開啟它。
首先，定義包名稱。 由於這是一個測試文件，並且目錄名為「store」，因此套件必須命名為「store_test」。
在此套件中，就像在「main.go」中一樣，我們必須導入以下劃線前綴的「pq」。
為了使用「sqlx」連接到 Postgres 資料庫，這是必需的。
然後，我們將定義一個測試套件。 這是「testify」套件的一個功能。
首先，定義一個名為「StoreTestSuite」的結構類型，嵌入「testify」庫中的「suite.Suite」類型，然後新增一個名為「db」的未匯出字段，我們將用它來儲存與測試資料庫。
我們可以為該套件內的所有測試共用此設定。
然後，在此類型上定義一個名為「SetupTest」的方法。
在內部，從環境中取得測試資料庫的連接字串。
使用「MustConnect」連接到資料庫，並將指向該連接的指標儲存在「db」欄位中。
最後，執行此查詢以清空「users」表，以便我們可以使用空資料庫開始每個測試運行。
為了讓 Go 測試運行器執行這個測試套件，我們需要定義一個常規的 Go 測試範例。
在此函數內，我們使用測試運行程序提供的「t」參數和新初始化的「StoreTestSuite」結構來運行「suite.Run」。
接下來，讓我們為「UserStore」定義一些測試範例。
在「store」目錄中，建立一個名為「user_store_test.go」的檔案並在程式碼編輯器中開啟它。
首先聲明包名稱，即「store_test」。
然後，將測試範例定義為「StoreTestSuite」類型上名為「TestInsertUser」的方法。
在此範例中，我們將測試在使用有效參數呼叫時儲存是否可以將使用者保留在資料庫中。
首先，我們需要將密碼雜湊聲明為單獨的變數。
這是因為使用者結構體上的「PasswordHash」欄位是指標類型，如果它儲存在變數中，我們只能取得指向字串的指標。
然後，我們可以使用範例電子郵件和對「passwordHash」變數的參考來實例化一個 User 結構。
然後，使用測試資料庫連接建立用戶儲存。
最後，我們可以使用對使用者結構的引用來呼叫「InsertUser」。
然後，確保沒有傳回錯誤，並斷言結果的 ID 欄位大於 0。
由於 ID 列是由資料庫產生的，因此檢查該欄位是否非零是確保該值已正確保存的好方法。
然後，我們可以檢查電子郵件地址和密碼雜湊值是否與我們傳遞給「InsertUser」的值相同。
我們可以使用指令「go test -v ./...」來執行整個專案的測試。
然而，我們可以透過定義一個「make」目標來為我們運行測試，從而節省一些輸入。
在「Makefile」中，定義一個名為「test」的目標，並依賴「db.test.prepare」。
然後，添加命令來運行測試。
現在，當我們執行「make test」時，該命令應該準備好測試資料庫並執行所有測試。
我們看到所有的例子都應該通過。
現在，讓我們透過測試用戶數量來改進我們的測試。 當我們在資料庫中插入使用者時，使用者數應該會改變一，因此我們可以在呼叫「InsertUser」之前和之後查詢使用者數。
在「user_store_test.go」檔案中，定義一個名為「countUsers」的函數，該函數接受資料庫連線並傳回一個整數和一個錯誤。
在裡面，定義一個整數變數來儲存計數查詢的結果。
然後，執行此 SQL 查詢來計算「users」表中的所有記錄，並將傳回值掃描到「result」變數中。
最後傳回結果以及`Scan`回傳的錯誤。
在測試範例中，在呼叫「InsertUser」之前呼叫此函數對使用者進行計數，並確保沒有傳回錯誤。
然後，在通話後執行相同的操作。 最後，新增一個斷言來檢查呼叫「InsertUser」後的使用者計數是否等於初始計數加一。
請注意，在呼叫「Equal」時，第一個參數是預期值，第二個參數是實際值。
如果我們現在運行「make test」，所有範例仍然應該通過。
在實現實際的使用者身份驗證之前，我們需要一種透過電子郵件地址從資料庫中檢索使用者的方法。
開啟「user_store.go」檔案。 首先，我們在 UserStore 結構上定義一個名為 GetUserByEmail 的方法，該方法接受電子郵件地址並傳回指向 User 結構的指標和錯誤。
在此方法中，定義一個變數來儲存 SQL 查詢的結果。
然後，查詢資料庫並將傳回值掃描到「result」變數中。 SQL 語法包含電子郵件地址的佔位符，因此我們需要將電子郵件地址作為參數傳遞給「Get」方法。
如果操作返回錯誤，我們返回「nil」並包裝錯誤。 否則，我們傳回對「result」變數的引用和「nil」錯誤。
現在，讓我們測試一下 `GetUserByEmail` 是否正常運作。 在「user_store_test.go」檔案中，新增一個名為「TestGetUserByEmail」的測試範例。
首先，我們將使用者插入資料庫。 我們為新使用者定義參數，將它們插入資料庫，並檢查是否沒有回傳錯誤。
首先測試快樂路徑。 使用我們要測試的電子郵件地址定義一段字串。 所有這些都是同一電子郵件地址的變體，只是大小寫不同。 由於「users」表中的「email」列不區分大小寫，因此查詢所有這些列應傳回相同的使用者記錄。
對於切片中的每個位址，我們使用「GetUserByEmail」查詢資料庫，檢查是否沒有錯誤，最後，我們斷言傳回的「User」與我們正在尋找的記錄具有相同的「ID」。
然後，我們使用另一個電子郵件地址查詢資料庫。 查詢將傳回一個錯誤，因此我們可以檢查傳回的錯誤是否包裝了「ErrNoRows」，這是如果查詢沒有傳回任何內容資料庫應該傳回的內容。
最後，斷言傳回的使用者記錄是一個「nil」指標。
現在，如果我們運行「make test」，所有測試仍然應該通過。
現在我們可以在「User」結構上實作一個方法來檢查密碼嘗試。 在程式碼編輯器中開啟「types」目錄中的「user.go」檔案。
讓我們先考慮所有可能出錯的事情。 首先可能發生的事情是用戶記錄沒有「PasswordHash」或該列無效。
您可能認為創建沒有密碼的用戶沒有太大意義，但在某些情況下這些用戶可能很有用。
例如，有時您只想允許使用者使用 API 金鑰存取您的系統，或用於自動化工作流程（例如按固定計畫執行的後台作業）。
我們能想到的另一個錯誤是使用者輸入的密碼不正確。
對於這兩種情況，讓我們使用函數「errors.New」定義錯誤類型。
然後，在「User」結構上定義一個名為「CheckPassword」的方法，將密碼作為字串並傳回一個布林值和一個錯誤。
從快樂的道路開始：如果一切正確，則傳回 true 和 nil 錯誤。
如果「PasswordHash」欄位為「nil」或不以 Argon2id 的前綴開頭，則傳回「false」和「ErrNoPasswordSet」錯誤。
然後我們可以運行正確的密碼檢查。
如果檢查回傳錯誤，則傳回「false」並包裝錯誤。
如果密碼不正確，則傳回 false 和 `ErrInvalidPassword` 錯誤。
現在，讓我們實作一個「用戶服務」。 在此設定中，服務充當儲存和請求處理程序之間的連結。
在專案根目錄下建立一個名為「service」的目錄。
在此目錄中，建立一個名為「user_service.go」的檔案並在程式碼編輯器中開啟它。
首先定義包名稱。
然後，定義一個名為「UserService」的結構體，其中包含一個名為「store」的私有字段，該字段將保存一個「UserStore」。
定義一個名為「NewUserService」的函數，取得指向資料庫連接的指標並傳回「UserService」結構。
在此函數中，傳回一個帶有「UserStore」的「UserService」結構，並使用給定的資料庫連接進行初始化。
這將是我們的建構函數，我們將用它來初始化「UserService」結構。
然後，定義一個名為「AuthenticateUserByEmailPassword」的方法，該方法接受電子郵件和密碼，並傳回指向「User」結構的指標和錯誤。
首先，透過電子郵件地址取得使用者。 如果此操作傳回錯誤，則傳回「nil」和錯誤。
然後，透過呼叫我們剛剛實現的「CheckPassword」方法來檢查密碼。 如果密碼檢查回傳錯誤，則傳回「nil」和錯誤。
最後，如果該檢查通過，則表示該使用者存在且密碼正確。
我們可以返回用戶並且沒有錯誤。
現在，讓我們為用戶服務編寫一些測試。
我們必須在「service」目錄中建立一個名為「service_test.go」的檔案。
該文件與商店包的文件幾乎完全相同，因此我不會費心手動將其寫出來。
相反，我將使用名為「sed」的命令列工具。 此命令將讀取檔案「store_test.go」，將每次出現的「Store」替換為「Service」，並將結果列印到標準輸出。 現在，我將其傳輸到一個名為「tee」的命令，該命令還將文字寫入我作為其參數傳遞的檔案中。
正如我們所看到的，這為我們提供了一個新的測試套件和 Go 測試範例的結構類型。
現在，在「service」目錄中建立一個名為「user_service_test.go」的文件，並在程式碼編輯器中開啟它。
在「ServiceTestSuite」結構上定義一個名為「TestAuthenticateUserByEmailPassword」的測試範例。
首先將測試資料插入資料庫。
首先，定義一個密碼變量，並使用預設參數使用「argon2id」對其進行哈希處理。
斷言「CreateHash」函數沒有回傳錯誤。
然後，使用唯一的電子郵件地址和我們剛剛產生的密碼雜湊定義一個「User」結構。
初始化一個`UserStore`並將`User`結構插入資料庫，然後確保沒有回傳錯誤。
現在，我們可以從快樂路徑開始測試實際功能。
使用資料庫連線初始化「UserService」，然後使用正確的電子郵件和密碼呼叫「AuthenticateUserByEmailPassword」。
確保沒有傳回錯誤，並斷言方法呼叫傳回的「User」結構與我們建立的「User」具有相同的 ID。
然後，如果我們傳遞正確的電子郵件和無效的密碼，我們應該得到一個「nil」使用者和一個「ErrInvalidPassword」。
如果我們傳遞一個不存在的電子郵件地址和原始使用者的密碼，我們應該得到一個「nil」和一個「ErrNoRows」。
最後，執行此 SQL 程式碼將此使用者的密碼雜湊更新為無效值。
如果我們嘗試使用正確的電子郵件和密碼進行身份驗證，我們應該會收到「nil」使用者和「ErrNoPasswordSet」錯誤。
如果您現在運行「make test」，則所有測試都應該通過。
這是第二部分的結尾。
這是一個很長的視頻，如果您已經看完了，那麼恭喜您。
我們已經成功實現了一些與資料庫操作和密碼雜湊相關的功能。
在下一個影片中，我們可以進一步了解這些知識並實現用戶註冊和登入視圖。
如果您喜歡這個視頻，請給我點個讚。
它對 YouTube 演算法確實有幫助。 如果您感覺非常慷慨，請考慮訂閱我的頻道，這樣我就可以變得富有和出名。
我希望你學到了一些東西，我們下一篇再見。
