## Introduction

In my previous video, I showed you how to connect to a Postgres database in Go using `sqlx` and `pq`.
We also created a database table to store user data.
Today, I would like to build on that foundation to implement password authentication using Argon2.
If you have watched my previous video, you can pick up where we left off, but if you haven't, it's also fine.
There is the Github repo in the description below and you can use it as a starting point.

## How password hashing works

First, we need to understand how password hashing algorithms work.
Meet Bob. Bob wants to create an account on our website. He inputs his email address and a password.
We need to transform his password in such a way that we can, at any time, check if the password is correct.
However, we also need to make sure that the bad guys won't be able to easily guess what his password is, just by looking at the encrypted form.
This is why password hashing algorithms were invented.
We take Bob's password, mix it together with a random value called "salt," and apply some sort of complex and slow computations, and we end up with a string that looks like this.
This string contains an identifier of the hashing algorithm, its parameters, the salting value, and the result of all those computations.
Whenever Bob wants to sign in, we take his password, add the salt and apply the same computations.
If we end up with the same value, it means that the password is correct and that we can let Bob into the system.

## Installing Argon2id library for Go

In this video, we're going to be using a password hashing library called "argon2id".
Let's start by installing this library.
If you have trouble finding it, there is a link in the description below.
Open a terminal and cd into the directory for the "goma" project that we started in the previous video.
On the website of the package, click on the clipboard icon to copy the import path to the system clipboard.
Then, in the terminal, type `go get `, then paste the import path and press Enter.

## Argon2id presentation and demonstration

Using `mkdir -p`, create a directory at `exp/argon`, and inside that directory, create a file named `main.go` and open it in a code editor.
The `exp` stands for "experimental", because we are going to write a smaller program before integrating the password hashing algorithm into the bigger system.
In this file, define `package main` and `func main()`.
Inside `main`, we define a `password` variable, then create a new password hash based on the plain text password and default hashing parameters.
If any error occurred during the hashing process, we log the error and exit, otherwise we print the hashed password.
Next, we try out a few passwords to see if they match.
For each password, we run the check and if it raises any errors, we log the error to the standard output and exit.
Otherwise, we print the tested password and the result of the check.
When we run this program, we should see a password hash string printed to the terminal.
Below that, we see all the passwords that we tested. As we can see, only the original password matches the test.
If you run the program several times, you may notice that the password digest is different every time.
This is because of the random salting value.
The algorithm is designed in this way, so that in case of a database breach, breaking one password hash would not compromise other accounts.

## Setting up types

Now that we know how Argon2 works, we can write the logic interacting with the database.
In an MVC model, this would belong to the model layer.
Since we are not working with a framework here, the project structure won't be exactly the same.
Let's start by defining a user type.
Back in the root directory of the project, create a directory called `types`.
Inside this directory, create a file named `user.go` and open it in a code editor.
Start by defining the package name, then define a `User` struct.
We need to map every column in the database table to a field on the struct.
For the `id` column, we define a struct field called "ID", with two capital letters.
Every column in the struct must start with a capital letter, otherwise `sqlx` won't be able to map the columns to their respective struct fields.
Since the struct field name is different from the column name in the database, we need to add an annotation after the field type to tell `sqlx` to match this field to the `id` column.
Then we do a similar thing for `email`.
For the `password_hash` column, we need to define the struct field as a string pointer.
This is because the corresponding database column does not have a `not null` constraint.
With a pointer type, `sqlx` can map null values to null pointers.
If we used a regular value type, trying to scan a null value would result in a runtime exception.
For the remaining two columns, we use `time.Time`. This is the default data type for dates and times in the Go standard library.

## Implement userStore, InsertUser()

Now that we have the `User` struct defined, let's build a "store".
In this setup, the "store" module should define operations interacting directly with the persistence layer, such as inserting, reading, or deleting data.
For the more advanced use cases, such as data validation or password hashing, we will later define another module called a "service".
In the root directory of the project, create a directory called `store`.
Inside this directory, create a file named `user_store.go` and open it in a code editor.
Start by defining the package name, then define an unexported struct called `userStore`.
This struct will only have one field called DB, where we can store a pointer to a `sqlx` database connection.
By keeping our own database connection within the store struct, we can write unit tests connecting to a dedicated testing database.
Define an exported function called `NewUserStore` that accepts a database connection and returns a `userStore` struct.
Within the function body, return a `userStore` struct with the same database connection.
Since the `db` field on the struct is private, only functions within the same package can set this field, and that's why we need to define a constructor function.
Define an exported method called `InsertUser` on the `userStore` type.
This method accepts a pointer to a User struct and returns a pointer to a User struct and an error.
In this method, first define a variable to store the result of a SQL query.
Then, using the `Get` method on the database connection, run this insert query and scan the returned data into the `result` variable.
In the case of the `users` table, the only two columns that we need to define are `email` and `password_hash`, for everything else we can rely on the values generated by the database.
Therefore, we define two placeholders in the SQL syntax, and we pass the values of email and password hash as parameters.
Since we added a `returning *` clause to the query, the database will return all columns of the newly inserted record.
If any error occurred, we return `nil` and a wrapped error message. Otherwise, we return a pointer to the `result` variable and a `nil` error.

## Test database setup

At this point, we have a function that looks like it should work correctly, but we have no user interface to check if it works.
Let's write some unit tests instead.
Some people will likely argue that a unit test should never touch a real database, and that a test talking to a database is really an integration test, but honestly, I don't care.
First, we're going to need a database, and we will have to run migrations on that database.
As this is a task we will have to perform many times in the future, it makes sense to write it as a `make` target, so we can have it automated.
Since I am working on Debian, the `make` on my system will be GNU make.
If you are on macOS or on a BSD system, the default make on your system may be BSD make, in which case you may have to install GNU make separately and run all `make` commands as `gmake`.

## Writing a Makefile

In the root directory of the project, create a file named `Makefile`, with the first letter capitalized, and open it in a text editor.
Now, we are going to define a "target" called `db.test.prepare`.
First, type the name of the target, followed by a colon.
The following lines with instructions must be indented with one tab.
Create the test database, and ignore any errors.
This is the most concise way of creating a database only if it doesn't exist.
Then, run migrations using `goose up`, passing the `TEST_DATABASE_URL` variable to `goose` as the connection string.
The at sign at the beginning of the line instructs make not to print the command before it is executed.

## Add guard target to Makefile

Now, in this target we are referencing two environment variables, one for the database name and another one for the connection string.
We need to make sure that both variables are set before we do anything.
To this end, we can implement a guard.
Add a target called `guard-%`, and inside this, add this scary looking command. Now, what `test -n` does is simply check if its argument is a non-empty string, and if this command fails, we print a nice error message with `echo` and exit with a non-zero exit code.
Now, add these two guards as dependencies of the `db.test.prepare` target.
If you try to run `make db.test.prepare` now, you will get an error message from the guard target.
Let's add these two environment variables to our `.envrc` file.
Set `TEST_DATABASE_NAME` to `goma_test`, then set `TEST_DATABASE_URL` to a connection string for this database.
Do note that the expression on the screen uses variable interpolation rather than a hardcoded name.
If you have configured `direnv` correctly, when you save this file and open a new shell, you should see an error message asking you to run `direnv allow`.
If you don't use `direnv`, you can set the correct environment variables by sourcing this file.
When you run `make db.test.prepare` now, it should correctly create a database and run migrations.
You can verify this by connect to the database and seeing its schema.

## Install `testify`

In the tests, we are going to use a library called `testify` to improve our testing experience.
On the website of `testify` package in the Go package registry, copy the import path of `testify` into the system clipboard.
In the root directory of the project, install the package using `go get`, pasting the import path.

## Set up `StoreTestSuite`

Now, inside the `store` directory, create a file called `store_test.go`, and open it in a text editor.
First, define the package name. Since this is a test file and the directory name is `store`, the package must be named `store_test`.
In this package, just like in `main.go`, we're going to have to import `pq`, prefixed with an underscore.
This is necessary in order to connect to a Postgres database using `sqlx`.
Then, we are going to define a test suite. This is a feature of the `testify` package.
First, define a struct type called `StoreTestSuite`, embedding the `suite.Suite`, and on this struct, add a `db` field.
We can share this setup for all tests inside this package.
We're going to use this field to store a connection to the test database.
Then, define a method called `SetupTest` on this type.
Inside, fetch the connection string for the test database from the environment.
Connect to the database using `MustConnect`, and store a pointer to the connection in the `db` field.
Finally, execute this query to empty the `users` table, so we can start each test run with an empty database.
In order for Go to execute this example, we need to define a regular Go test example.
Inside this function, we run `suite.Run` with the `t` struct passed by the test runner and a `StoreTestSuite` struct.

## Add examples for `userStore`

Next, let's define some test examples for the `userStore`.
Inside the `store` directory, create a file named `user_store_test.go` and open it in a text editor.
Start by declaring the package name, which is `store_test`.
Then, define a test example as a method called `TestInsertUser` on the `StoreTestSuite` type.
In this example, we are going to test if the store can persist a user in the database if call it with valid parameters.
First, we need to declare the password hash as a separate variable.
This is because the `PasswordHash` field on the user struct is a pointer type, and we can only obtain a pointer to a string if it is stored in a variable.
Then, we can instantiate a User struct with an example email and a reference to the `passwordHash` variable.
Then, construct a user store with a test database connection.
Finally, we can call `InsertUser` with a reference to the user struct.
Then, we ensure no error was returned, and assert that the ID field of the result is greater than 0.
Since the ID column is generated by the database, checking if the field is non-zero is a good way to ensure that the value has been correctly saved.
Then, we can check that the email address and the password hash have the same values as the ones we passed to `InsertUser`.

## Running tests

We can run the tests for the whole project using `go test -v ./...`.
However, we can save ourselves some typing by defining a `make` target to run the tests for us.
In the `Makefile`, define a target called `test` with a dependency on `db.test.prepare`.
Then, add the command to run tests.
Now, when we run `make test`, the command should prepare the test database and run tests.
We see that all examples should be passing.

## Testing user count

Now, let's improve our tests by testing the user count. When we insert a user into the database, the user count should change by one, so we can query the user count before and after the call to `InsertUser`.
In the `user_store_test.go` file, define a function called `countUsers` that takes a database connection and returns an integer and an error.
Inside, define an integer variable to store the result of the count query.
Then, run this SQL query to count all records in the `users` table and scan the returned value into the `result` variable.
Finally, return the result and the error returned by `Scan`.
In the test example, call this function to count users before the call to `InsertUser`, and ensure that no error occurred.
Then, do the same after the call. Finally, add an assertion to check that the count of users after the insertion should be the count before plus one. Do note that in the call to `Equal`, the first argument is the expected value and the second one is the actual value.
If we run `make test` now, all the examples should still be passing.

## Implementing `GetUserByEmail`

Before we can implement the actual authentication, we're also going to need a way to retrieve a user from the database by their email address.
Open the `user_store.go` file. Let's begin by defining a method called `GetUserByEmail` on the `userStore` struct that takes an email address and returns a pointer to a `User` struct and an error.
Inside this method, define a variable to store the result of a SQL query.
Then, query the database and scan the returned value into the `result` variable. The SQL query contains a placeholder for the email address, so we need to pass the email address as a parameter to the `Get` method.
If the operation returned an error, we return `nil` and wrap the error. Otherwise, we return a reference to the `result` variable and a `nil` error.

## Testing `GetUserByEmail`

Now, let's test if `GetUserByEmail` works correctly. In the `user_store_test.go` file, add a test example called `TestGetUserByEmail`.
First, we insert a user into the database. We define the parameters for a new user, insert them into the database, and check that no error was returned.
Start by testing the happy path. Define a slice of strings with email addresses that we want to test. All of these are variants of the same email address, just with different capitalization. Since the `email` column in the `users` table is case-insensitive, querying for all of these should return the same user record.
For each address in the slice, we query the database with `GetUserByEmail`, check that there was no error, and finally, we assert that the returned `User` has the same `ID` as the record we are looking for.
Then, we query the database with another email address. The query will return an error, so we can check if the returned error wraps `ErrNoRows`, which is what the database should return if nothing was returned from a query.
Finally, assert that the returned user record is a `nil` pointer.
Now, if we run `make test`, all the tests should still be passing.
