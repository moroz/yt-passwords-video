## Introduction

In my previous video, I showed you how to connect to a Postgres database in Go using `sqlx` and `pq`.
We also created a database table to store user data.
Today, I would like to build on that foundation to implement password authentication using Argon2.
If you have watched my previous video, you can pick up where we left off, but if you haven't, it's also fine.
There is the Github repo in the description below and you can use it as a starting point.

## How password hashing works

First, we need to understand how password hashing algorithms work.
Meet Bob. Bob wants to create an account on our website. He inputs his email address and a password.
We need to transform his password in such a way that we can, at any time, check if the password is correct.
However, we also need to make sure that the bad guys won't be able to easily guess what his password is, just by looking at the encrypted form.
This is why password hashing algorithms were invented.
We take Bob's password, mix it together with a random value called "salt," and apply some sort of complex and slow computations, and we end up with a string that looks like this.
This string contains an identifier of the hashing algorithm, its parameters, the salting value, and the result of all those computations.
Whenever Bob wants to sign in, we take his password, add the salt and apply the same computations.
If we end up with the same value, it means that the password is correct and that we can let Bob into the system.

## Installing Argon2id library for Go

In this video, we're going to be using a password hashing library called "argon2id".
Let's start by installing this library.
If you have trouble finding it, there is a link in the description below.
Open a terminal and cd into the directory for the "goma" project that we started in the previous video.
On the website of the package, click on the clipboard icon to copy the import path to the system clipboard.
Then, in the terminal, type `go get `, then paste the import path and press Enter.

## Argon2id presentation and demonstration

Using `mkdir -p`, create a directory at `exp/argon`, and inside that directory, create a file named `main.go` and open it in a code editor.
The `exp` stands for "experimental", because we are going to write a smaller program before integrating the password hashing algorithm into the bigger system.
In this file, define `package main` and `func main()`.
Inside `main`, we define a `password` variable, then create a new password hash based on the plain text password and default hashing parameters.
If any error occurred during the hashing process, we log the error and exit, otherwise we print the hashed password.
Next, we try out a few passwords to see if they match.
For each password, we run the check and if it raises any errors, we log the error to the standard output and exit.
Otherwise, we print the tested password and the result of the check.
When we run this program, we should see a password hash string printed to the terminal.
Below that, we see all the passwords that we tested. As we can see, only the original password matches the test.
If you run the program several times, you may notice that the password digest is different every time.
This is because of the random salting value.
The algorithm is designed in this way, so that in case of a database breach, breaking one password hash would not compromise other accounts.

## Setting up types

Now that we know how Argon2 works, we can write the logic interacting with the database.
In an MVC model, this would belong to the model layer.
Since we are not working with a framework here, the project structure won't be exactly the same.
Let's start by defining a user type.
Back in the root directory of the project, create a directory called `types`.
Inside this directory, create a file named `user.go` and open it in a code editor.
Start by defining the package name, then define a `User` struct.
We need to map every column in the database table to a field on the struct.
For the `id` column, we define a struct field called "ID", with two capital letters.
Every column in the struct must start with a capital letter, otherwise `sqlx` won't be able to map the columns to their respective struct fields.
Since the struct field name is different from the column name in the database, we need to add an annotation after the field type to tell `sqlx` to match this field to the `id` column.
Then we do a similar thing for `email`.
For the `password_hash` column, we need to define the struct field as a string pointer.
This is because the corresponding database column does not have a `not null` constraint.
With a pointer type, `sqlx` can map null values to null pointers.
If we used a regular value type, trying to scan a null value would result in a runtime exception.
For the remaining two columns, we use `time.Time`. This is the default data type for dates and times in the Go standard library.

## Implement userStore, InsertUser()

Now that we have the `User` struct defined, let's build a "store".
In this setup, the "store" module should define operations interacting directly with the persistence layer, such as inserting, reading, or deleting data.
For the more advanced use cases, such as data validation or password hashing, we will later define another module called a "service".
In the root directory of the project, create a directory called `store`.
Inside this directory, create a file named `user_store.go` and open it in a code editor.
Start by defining the package name, then define an unexported struct called `userStore`.
This struct will only have one field called DB, where we can store a pointer to a `sqlx` database connection.
By keeping our own database connection within the store struct, we can write unit tests connecting to a dedicated testing database.
Define an exported function called `NewUserStore` that accepts a database connection and returns a `userStore` struct.
Within the function body, return a `userStore` struct with the same database connection.
Since the `db` field on the struct is private, only functions within the same package can set this field, and that's why we need to define a constructor function.
Define an exported method called `InsertUser` on the `userStore` type.
This method accepts a pointer to a User struct and returns a pointer to a User struct and an error.
In this method, first define a variable to store the result of a SQL query.
Then, using the `Get` method on the database connection, run this insert query and scan the returned data into the `result` variable.
In the case of the `users` table, the only two columns that we need to define are `email` and `password_hash`, for everything else we can rely on the values generated by the database.
Therefore, we define two placeholders in the SQL syntax, and we pass the values of email and password hash as parameters.
Since we added a `returning *` clause to the query, the database will return all columns of the newly inserted record.
If any error occurred, we return `nil` and a wrapped error message. Otherwise, we return a pointer to the `result` variable and a `nil` error.

## Test database setup

At this point, we have a function that looks like it should work correctly, but we have no user interface to check if it works.
Let's write some unit tests instead.
Some people will likely argue that a unit test should never touch a real database, and that a test talking to a database is really an integration test, but honestly, I don't care.
First, we're going to need a database, and we will have to run migrations on that database.
As this is a task we will have to perform many times in the future, it makes sense to write it as a `make` target, so we can have it automated.
Since I am working on Debian, the `make` on my system will be GNU make.
If you are on macOS or on a BSD system, the default make on your system may be BSD make, in which case you may have to install GNU make separately and run all `make` commands as `gmake`.

## Writing a Makefile

In the root directory of the project, create a file named `Makefile`, with the first letter capitalized, and open it in a text editor.
Now, we are going to define a "target" called `db.test.prepare`.
First, type the name of the target, followed by a colon.
The following lines with instructions must be indented with one tab.
Create the test database, and ignore any errors.
This is the most concise way of creating a database only if it doesn't exist.
Then, run migrations using `goose up`, passing the `TEST_DATABASE_URL` variable to `goose` as the connection string.
The at sign at the beginning of the line instructs make not to print the command before it is executed.

## Add guard target to Makefile

Now, in this target we are referencing two environment variables, one for the database name and another one for the connection string.
We need to make sure that both variables are set before we do anything.
To this end, we can implement a guard.
Add a target called `guard-%`, and inside this, add this scary looking command. Now, what `test -n` does is simply check if its argument is a non-empty string, and if this command fails, we print a nice error message with `echo` and exit with a non-zero exit code.
Now, add these two guards as dependencies of the `db.test.prepare` target.
If you try to run `make db.test.prepare` now, you will get an error message from the guard target.
Let's add these two environment variables to our `.envrc` file.
Set `TEST_DATABASE_NAME` to `goma_test`, then set `TEST_DATABASE_URL` to a connection string for this database.
Do note that the expression on the screen uses variable interpolation rather than a hardcoded name.
If you have configured `direnv` correctly, when you save this file and open a new shell, you should see an error message asking you to run `direnv allow`.
If you don't use `direnv`, you can set the correct environment variables by sourcing this file.
When you run `make db.test.prepare` now, it should correctly create a database and run migrations.
You can verify this by connect to the database and seeing its schema.

## Install `testify`

In the tests, we are going to use a library called `testify` to improve our testing experience.
On the website of `testify` package in the Go package registry, copy the import path of `testify` into the system clipboard.
In the root directory of the project, install the package using `go get`, pasting the import path.

## Set up `StoreTestSuite`

Now, inside the `store` directory, create a file called `store_test.go`, and open it in a text editor.
First, define the package name. Since this is a test file and the directory name is `store`, the package must be named `store_test`.
In this package, just like in `main.go`, we're going to have to import `pq`, prefixed with an underscore.
This is necessary in order to connect to a Postgres database using `sqlx`.
Then, we are going to define a test suite. This is a feature of the `testify` package.
First, define a struct type called `StoreTestSuite`, embedding the `suite.Suite`, and on this struct, add a `db` field.
We can share this setup for all tests inside this package.
We're going to use this field to store a connection to the test database.
Then, define a method called `SetupTest` on this type.
Inside, fetch the connection string for the test database from the environment.
Connect to the database using `MustConnect`, and store a pointer to the connection in the `db` field.
Finally, execute this query to empty the `users` table, so we can start each test run with an empty database.
In order for Go to execute this example, we need to define a regular Go test example.
Inside this function, we run `suite.Run` with the `t` struct passed by the test runner and a `StoreTestSuite` struct.

## Add examples for `userStore`

Next, let's define some test examples for the `userStore`.
