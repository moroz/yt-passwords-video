## Introduction

In my previous video, I showed you how to connect to a Postgres database in Go using `sqlx` and `pq`.
We also created a database table to store user data.
Today, I would like to build on that foundation to implement password authentication using Argon2.
If you have watched my previous video, you can pick up where we left off, but if you haven't, it's also fine.
There is the Github repo in the description below and you can use it as a starting point.

## How password hashing works

First, we need to understand how password hashing algorithms work.
Meet Bob. Bob wants to create an account on our website. He inputs his email address and a password.
We need to transform his password in such a way that we can, at any time, check if the password is correct.
However, we also need to make sure that the bad guys won't be able to easily guess what his password is, just by looking at the encrypted form.
This is why password hashing algorithms were invented.
We take Bob's password, mix it together with a random value called "salt," and apply some sort of complex and slow computations, and we end up with a string that looks like this.
This string contains an identifier of the hashing algorithm, its parameters, the salting value, and the result of all those computations.
Whenever Bob wants to sign in, we take his password, add the salt and apply the same computations.
If we end up with the same value, it means that the password is correct and that we can let Bob into the system.

## Installing Argon2id library for Go

In this video, we're going to be using a password hashing library called "argon2id".
Let's start by installing this library.
If you have trouble finding it, there is a link in the description below.
Open a terminal and cd into the directory for the "goma" project that we started in the previous video.
On the website of the package, click on the clipboard icon to copy the import path to the system clipboard.
Then, in the terminal, type `go get `, then paste the import path and press Enter.

## Argon2id presentation and demonstration

Using `mkdir -p`, create a directory at `exp/argon`, and inside that directory, create a file named `main.go` and open it in a code editor.
The `exp` stands for "experimental", because we are going to write a smaller program before integrating the password hashing algorithm into the bigger system.
In this file, define `package main` and `func main()`.
Inside `main`, we define a `password` variable, then create a new password hash based on the plain text password and default hashing parameters.
If any error occurred during the hashing process, we log the error and exit, otherwise we print the hashed password.
Next, we try out a few passwords to see if they match.
For each password, we run the check and if it raises any errors, we log the error to the standard output and exit.
Otherwise, we print the tested password and the result of the check.
When we run this program, we should see a password hash string printed to the terminal.
Below that, we see all the passwords that we tested. As we can see, only the original password matches the test.
If you run the program several times, you may notice that the password digest is different every time.
This is because of the random salting value.
The algorithm is designed in this way, so that in case of a database breach, breaking one password hash would not compromise other accounts.

## Setting up types

Now that we know how Argon2 works, we can write the logic interacting with the database.
In an MVC model, this would belong to the model layer.
Since we are not working with a framework here, the project structure won't be exactly the same.
Let's start by defining a user type.
Back in the root directory of the project, create a directory called `types`.
Inside this directory, create a file named `user.go` and open it in a code editor.
Start by defining the package name, then define a `User` struct.
We need to map every column in the database table to a field on the struct.
For the `id` column, we define a struct field called "ID", with two capital letters.
Every column in the struct must start with a capital letter, otherwise `sqlx` won't be able to map the columns to their respective struct fields.
Since the struct field name is different from the column name in the database, we need to add an annotation after the field type to tell `sqlx` to match this field to the `id` column.
Then we do a similar thing for `email`.
For the `password_hash` column, we need to define the struct field as a string pointer.
This is because the corresponding database column does not have a `not null` constraint.
With a pointer type, `sqlx` can map null values to null pointers.
If we used a regular value type, trying to scan a null value would result in a runtime exception.
For the remaining two columns, we use the type `time.Time`. This is the default data type for dates and times in the Go standard library.

## Setting up UserStore

Now that we have the `User` struct defined, let's build a "store".
In this setup, the "store" module should define operations interacting directly with the persistence layer, such as inserting, reading, or deleting data.
For the more advanced use cases, such as data validation or password hashing, we will later define another module called a "service".
In the root directory of the project, create a directory called `store`.
Inside this directory, create a file named `user_store.go` and open it in a code editor.
Start by defining the package name, then define an unexported struct called `userStore`.
This struct will only have one field called DB, where we can store a pointer to a `sqlx` database connection.
By keeping our own database connection within the store struct, we can write unit tests connecting to a dedicated testing database.
Define an exported function called `NewUserStore` that accepts a database connection and returns a `userStore` struct.
Within the function body, return a `userStore` struct with the same database connection.
Since the `db` field on the struct is private, only functions within the same package can set this field, and that's why we need to define a constructor function.
Define an exported method called `InsertUser` on the `userStore` type.
This 
